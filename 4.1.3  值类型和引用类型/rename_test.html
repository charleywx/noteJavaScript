<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>test</title>
<script>

//【示例1】在下面示例中，分别把值123复制3份给变量a、数组b和对象c，虽然它们的值是相等的，但是它们之间是相互独立的。
var n = 123, a, b = [], c = {};
a = n;					// 复制数字123
b[0] = n; 				// 复制数字123
c.x = n; 				// 复制数字123
(a == b[0]) && (a == c.x) && (b[0] == c.x) && alert("复制的值都是相等的");
						// 检测它们的值都是相等的
//【示例2】如果在函数中修改传递进来的值时，结果只能够影响这个参数值，并不会影响到原来的值。
var a = 123; 			// 原来的值
function f(x){
    x = x + x;
}
f(a); 					// 调用函数修改传递的值
alert(a); 				// 查看变量a的值是否受影响，返回值为123，说明没有变化

//【示例3】所有引用都具有相同的功能，通过编辑其中的引用变量的值，这种修改将会在原值及其他相关引用中体现出来。
var a = [1,2,3]; 		// 赋值数组引用
b = a; 					// 复制值
b[0] = 4; 				// 修改变量b中第一个元素的值
alert(a[0]); 			// 返回4，显示变量a中第一个元素的值也被修改为4
//但是，如果给变量b重新赋予新值，则新值不会影响原值内容。
var a = [1,2,3]; 		// 赋值数组引用
b = a; 					// 复制值
b = 4; 					// 为变量b重写赋值
alert(a[0]); 			// 变量a的内容保持不变


//【示例4】在下面代码中，把数组a作为参数传递给函数f，则在函数体内可以修改函数体外数组的元素值。
var a = [1,2,3];
function f(x){ 
    x[0] = 4; 					// 在函数中修改参数值
}
f(a); 							// 传递引用值
alert(a[0]); 					// 返回4，原值发生变化

//【示例5】在下面代码中，当对两个不同值进行引用时，尽管它们具有相同的字节构成，但是这两个引用的值却是不相等的。
var a = new Number(1); 		// 引用值a
var b = new Number(1); 		// 引用值b
var c = a; 						// 把a的引用赋值给c
alert(a==b); 					// 返回false
alert(a==c); 					// 返回true

//【示例6】在下面代码中，值类型数据是以实际值参与函数内部运算，因此与原值没有直接关系，而引用型数据是以引用地址参与运算，计算的结果会影响到引用地址所关联的原值。
var s = "abc";					// 字符串，值类型数据
var o = new String(s); 		// 字符串对象，被装箱后的字符串
function f(v){ 					// 运算函数
    v.toString = function(){	// 修改参数的方法toString()
        return 123;
    };
}
f(s); 					// 传入值
alert(s); 				// 返回字符串"abc"，说明运算没有对原数据造成影响
f(o); 					// 传入引用
alert(o); 				// 返回数值123，说明运算已经影响到原数据的内部结构


</script>
</head>
<body>
</body>
</html>
