<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>test</title>
<script type="text/javascript">


//【示例1】在下面示例中，匹配字符串"JavaScript"，不区分大小写。
var s = "JavaScript,not Javascript";
var r = /(Java)Script/gi;
var a = r.exec(s);		 		// 执行匹配操作
alert(RegExp.input); 			// 返回字符串"JavaScript,not Javascript"
alert(RegExp.leftContext); 
	// 返回空字符串，因为第一次匹配操作时，左侧没有内容
alert(RegExp.rightContext); 	// 返回字符串",not Javascript"
alert(RegExp.lastMatch); 		// 返回字符串"JavaScript "
alert(RegExp.lastParen); 		// 返回字符串"Java"

//【示例2】如果模式中包含多个分组，则会显示最后一个分组所匹配的字符。
var r = /(Java)(Script)/gi;
var a = r.exec(s); 				// 执行匹配操作
alert(RegExp.lastParen); 		// 返回字符串"Script"，而不再是"Java"

//【示例3】针对上面示例也可以这样设计。
var s = "JavaScript,not Javascript";
var r = /(Java)(Script)/gi;
var a = r.exec(s);
alert(RegExp.$_); 				// 返回字符串"JavaScript,not Javascript"
alert(RegExp["$`"]);			// 返回空字符串
alert(RegExp["$'"]);			// 返回字符串",not Javascript"
alert(RegExp["$&"]);			// 返回字符串"JavaScript "
alert(RegExp["$+"]);			// 返回字符串"Java"

//【示例4】在下面示例中，第一次执行匹配和第二次执行匹配时，这些静态属性值都会实时动态更新。
var s = "JavaScript,not Javascript";
var r = /Scrip(t)/gi; 			// 第一次定义的匹配模式
var a = r.exec(s); 				// 执行第一次匹配
alert(RegExp.$_); 				// 返回字符串"JavaScript,not Javascript"
alert(RegExp["$`"]);			// 返回字符串"Java"
alert(RegExp["$'"]);			// 返回字符串",not Javascript"
alert(RegExp["$&"]);			// 返回字符串"Script"
alert(RegExp["$+"]);			// 返回字符串"t"
var r = /Jav(a)/gi; 			// 第二次定义的匹配模式
var a = r.exec(s); 				// 执行第二次匹配
alert(RegExp.$_); 				// 返回字符串"JavaScript,not Javascript"
alert(RegExp["$`"]);			// 返回空字符串
alert(RegExp["$'"]); 			// 返回字符串"Script,not Javascript"
alert(RegExp["$&"]);			// 返回字符串"Java"
alert(RegExp["$+"]);			// 返回字符串"a"

//【示例5】multiline属性与上面几个属性不同，它不会根据每次执行的操作进行实时更新，而且它还可以控制所有正则表达式的m标志项。
var s = "a\nb\nc";
var r = /\w+$/g; 				// 定义匹配模式
var a = s.match(r); 			// 执行默认匹配，返回数组["c"]
RegExp.multiline = true; 		// 动态设置模式为多行匹配
var a = s.match(r); 			// 返回数组["a", "b", "c"] 

</script>
</head>

<body>
</body>
</html>
