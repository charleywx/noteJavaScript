<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>test</title>
<script type="text/javascript">


//【示例1】在下面示例中，演示如何定义一个构造函数，定义本地属性。
function f(){				// 声明一个构造类型
    this.a = 1; 			// 为构造类型声明一个本地属性
    this.b = function(){	// 为构造类型声明一个本地方法
        return this.a;
    };
}
var e =new f();			// 实例化构造类型
alert(e.a); 				// 调用实例对象的属性a，返回1
alert(e.b());				// 调用实例对象的方法b，提示1

e.a = 2;
alert(e.a);
alert(e.b());

//【示例2】本地属性可以在实例对象中被修改，但是不同实例对象之间不会相互响应。
function f(){				// 声明一个构造类型
    this.a = 1; 			// 为构造类型声明一个本地属性
}
var e =new f();			// 实例e
var g =new f();			// 实例g
alert(e.a); 				// 返回值为1，说明它继承了构造函数的初始值
alert(g.a); 				// 返回值为1，说明它继承了构造函数的初始值
e.a = 2; 					// 修改实例e的属性a的值
alert(e.a); 				// 返回值为2，说明实例e的属性a的值改变了
alert(g.a); 				// 返回值为1，说明实例g的属性a的值没有受影响

//【示例3】原型属性将会影响所有实例对象，修改任何原型属性值，则该构造函数的所有实例都会看到这种变化，这样就避免了本地属性修改的麻烦。
function f(){					// 声明一个构造类型
    f.prototype.a = 1; 			// 为构造类型声明一个原型属性
}
var e =new f();				// 实例e
var g =new f();				// 实例g
alert(e.a); 					// 返回值为1，说明它继承了构造函数的初始值
alert(g.a); 					// 返回值为1，说明它继承了构造函数的初始值
f.prototype.a = 2; 				// 修改原型属性值
alert(e.a); 					// 返回值为2，说明实例e的属性a的值改变了
alert(g.a); 					// 返回值为2，说明实例g的属性a的值改变了

function f(){}					// 声明一个空的构造类型
f.prototype.a = 1; 				// 在结构体外为构造类型声明一个原型属性
f.prototype.b = function(){	// 在结构体外为构造类型声明一个原型方法
    return f.prototype.a; 		// 返回原型属性值
}

Object.prototype.a = 1; 	// 声明Object的原型属性a的值为1
Function.prototype.a= 2; 	// 声明Function的原型属性a的值为2
alert(Object.a); 			// 返回2，说明属性a指向Function构造函数的原型
alert(Function.a); 			// 返回2，说明属性a指向Function构造函数的原型
var o = {}					// 空的对象直接量
alert(o.a); 				// 返回1，说明属性a指向Object构造函数的原型
var f = Object; 			// 引用Object构造函数
alert(f.a); 				// 返回2，说明属性a指向Function构造函数的原型
var f1 = new Function();	// 实例化Function对象
alert(f1.a); 				// 返回2，说明属性a指向Function构造函数的原型
var o1 = new Object();		// 实例化Object对象
alert(o1.a); 				// 返回1，说明属性a指向Object构造函数的原型



</script>
</head>
<body>
</body>
</html>
