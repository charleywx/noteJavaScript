<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>test</title>
<script type="text/javascript">


//【示例1】先看一个简单的示例。
var r = new RegExp("a");			// 构造最简单的正则表达式

var s = "javascript!=JAVA";	// 定义字符串直接量
var a = s.match(r); 			// 调用正则表达式执行匹配操作，返回匹配的数组
alert(a); 						// 返回数组[a]
alert(a.index); 				// 返回值为1

//【示例2】如果希望该正则表达式匹配字符串中所有的字母a，且不区分大小写，则可以在第二个参数中增加g和i修饰词。
var r = new RegExp("a","gi");	// 设置匹配模式为全局匹配，且不区分大小写

var s = "javascript!=JAVA";	// 字符串直接量
var a = s.match(r); 			// 匹配查找
alert(a); 						// 返回数组["a","a","A","A"]

//【示例3】RegExp()构造函数的第一个参数是一个字符串或者一个正则表达式，该参数构成了正则表达式的匹配主体。如果该参数是一个字符串，则可以是一个符合正则表达式规则的字符串。
var r = new RegExp("\\b\\w","gi");		// 构造正则表达式对象
var s = "javascript JAVA";				// 字符串直接量
var a = s.match(r); 					// 匹配查找
alert(a); 								// 返回数组["j", "J"]

//【示例4】如果RegExp()构造函数的第一个参数是一个正则表达式，则第二个参数可以省略。这时RegExp()构造函数将使用与正则表达式参数相同的匹配模式和修饰词创建一个新的RegExp对象。
var r = new RegExp("\\b\\w","gi");		// 构造正则表达式对象
var r1 = new RegExp(r); 
	// 把正则表达式变量作为参数传递给RegExp()构造函数
var s = "javascript JAVA";				// 字符串直接量
var a = s.match(r); 					// 匹配查找
alert(a); 								// 返回数组["j", "J"]

//【示例5】RegExp()可以作为普通函数进行调用。作为普通函数，RegExp()函数的行为与使用new运算符调用构造函数时一样。不过如果函数的参数是正则表达式，那么它仅返回正则表达式，而不再创建一个新的RegExp对象。
var a = new RegExp("\\b\\w","gi");		// 构造正则表达式对象
var b = new RegExp(a); 				// 对正则表达式对象进行再封装
var c = RegExp(a); 						// 返回正则表达式直接量
alert(a.constructor == RegExp); 		// 返回true
alert(b.constructor == RegExp); 		// 返回true
alert(c.constructor == RegExp); 		// 返回true



</script>
</head>

<body>
</body>
</html>
